{"version":3,"file":"ponyfill.es6.min.mjs","sources":["../../node_modules/web-streams-polyfill/dist/ponyfill.es6.mjs"],"sourcesContent":["/**\n * web-streams-polyfill v2.1.1\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    // do nothing\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nconst rethrowAssertionErrorRejection =  noop;\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction createArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction ArrayBufferCopy(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\nfunction IsFiniteNonNegativeNumber(v) {\n    if (IsNonNegativeNumber(v) === false) {\n        return false;\n    }\n    if (v === Infinity) {\n        return false;\n    }\n    return true;\n}\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\nfunction Call(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction CreateAlgorithmFromUnderlyingMethod(underlyingObject, methodName, algoArgCount, extraArgs) {\n    const method = underlyingObject[methodName];\n    if (method !== undefined) {\n        if (typeof method !== 'function') {\n            throw new TypeError(`${method} is not a method`);\n        }\n        switch (algoArgCount) {\n            case 0: {\n                return () => {\n                    return PromiseCall(method, underlyingObject, extraArgs);\n                };\n            }\n            case 1: {\n                return arg => {\n                    const fullArgs = [arg].concat(extraArgs);\n                    return PromiseCall(method, underlyingObject, fullArgs);\n                };\n            }\n        }\n    }\n    return () => promiseResolvedWith(undefined);\n}\nfunction InvokeOrNoop(O, P, args) {\n    const method = O[P];\n    if (method === undefined) {\n        return undefined;\n    }\n    return Call(method, O, args);\n}\nfunction PromiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(Call(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n    return false;\n}\nfunction ValidateAndNormalizeHighWaterMark(highWaterMark) {\n    highWaterMark = Number(highWaterMark);\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n    }\n    return highWaterMark;\n}\nfunction MakeSizeAlgorithmFromSizeFunction(size) {\n    if (size === undefined) {\n        return () => 1;\n    }\n    if (typeof size !== 'function') {\n        throw new TypeError('size property of a queuing strategy must be a function');\n    }\n    return chunk => size(chunk);\n}\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n    let prototype = null;\n    if (forAuthorCode === true) {\n        prototype = Object.prototype;\n    }\n    const obj = Object.create(prototype);\n    obj.value = value;\n    obj.done = done;\n    return obj;\n}\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._forAuthorCode = true;\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream, forAuthorCode = false) {\n    const reader = new ReadableStreamDefaultReader(stream);\n    reader._forAuthorCode = forAuthorCode;\n    return reader;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const readRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._reader._readRequests.push(readRequest);\n    });\n    return promise;\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        if (IsReadableStream(stream) === false) {\n            throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n        }\n        if (IsReadableStreamLocked(stream) === true) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    cancel(reason) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        return ReadableStreamDefaultReaderRead(this);\n    }\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode));\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return stream._readableStreamController[PullSteps]();\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nlet AsyncIteratorPrototype;\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    // We're running inside a ES2018+ environment, but we're compiling to an older syntax.\n    // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.\n    AsyncIteratorPrototype = {\n        // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )\n        // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator\n        [SymbolPolyfill.asyncIterator]() {\n            return this;\n        }\n    };\n    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (IsReadableStreamAsyncIterator(this) === false) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        const reader = this._asyncIteratorReader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        return transformPromiseWith(ReadableStreamDefaultReaderRead(reader), result => {\n            const done = result.done;\n            if (done) {\n                ReadableStreamReaderGenericRelease(reader);\n            }\n            const value = result.value;\n            return ReadableStreamCreateReadResult(value, done, true);\n        });\n    },\n    return(value) {\n        if (IsReadableStreamAsyncIterator(this) === false) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        const reader = this._asyncIteratorReader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (reader._readRequests.length > 0) {\n            return promiseRejectedWith(new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled'));\n        }\n        if (this._preventCancel === false) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ReadableStreamCreateReadResult(value, true, true));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith(ReadableStreamCreateReadResult(value, true, true));\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\nObject.defineProperty(ReadableStreamAsyncIteratorPrototype, 'next', { enumerable: false });\nObject.defineProperty(ReadableStreamAsyncIteratorPrototype, 'return', { enumerable: false });\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel = false) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorReader = reader;\n    iterator._preventCancel = Boolean(preventCancel);\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorReader')) {\n        return false;\n    }\n    return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    size = Number(size);\n    if (!IsFiniteNonNegativeNumber(size)) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nclass WritableStream {\n    constructor(underlyingSink = {}, strategy = {}) {\n        InitializeWritableStream(this);\n        const size = strategy.size;\n        let highWaterMark = strategy.highWaterMark;\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n        if (highWaterMark === undefined) {\n            highWaterMark = 1;\n        }\n        highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    get locked() {\n        if (IsWritableStream(this) === false) {\n            throw streamBrandCheckException('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    abort(reason) {\n        if (IsWritableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException('abort'));\n        }\n        if (IsWritableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    close() {\n        if (IsWritableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException('close'));\n        }\n        if (IsWritableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    getWriter() {\n        if (IsWritableStream(this) === false) {\n            throw streamBrandCheckException('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (wasAlreadyErroring === false) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure === true && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring === true) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure === true) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        if (IsWritableStream(stream) === false) {\n            throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n        }\n        if (IsWritableStreamLocked(stream) === true) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    get closed() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    get desiredSize() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    get ready() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    abort(reason) {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    close() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    releaseLock() {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk) {\n        if (IsWritableStreamDefaultWriter(this) === false) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\\'s closedness');\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nclass WritableStreamDefaultController {\n    /** @internal */\n    constructor() {\n        throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n    }\n    error(e) {\n        if (IsWritableStreamDefaultController(this) === false) {\n            throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    function startAlgorithm() {\n        return InvokeOrNoop(underlyingSink, 'start', [controller]);\n    }\n    const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n    const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n    const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, 'close', 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    const writeRecord = { chunk };\n    try {\n        EnqueueValueWithSize(controller, writeRecord, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (controller._started === false) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const writeRecord = PeekQueueValue(controller);\n    if (writeRecord === 'close') {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (preventAbort === false) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (preventCancel === false) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted === true) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown === true) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return PerformPromiseThen(ReadableStreamDefaultReaderRead(reader), result => {\n                    if (result.done === true) {\n                        return true;\n                    }\n                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, result.value), undefined, noop);\n                    return false;\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (preventAbort === false) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (preventCancel === false) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (preventClose === false) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (preventCancel === false) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown === true) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown === true) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\nclass ReadableStreamDefaultController {\n    /** @internal */\n    constructor() {\n        throw new TypeError();\n    }\n    get desiredSize() {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    close() {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('close');\n        }\n        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    error(e) {\n        if (IsReadableStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps]() {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested === true && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            return promiseResolvedWith(ReadableStreamCreateReadResult(chunk, false, stream._reader._forAuthorCode));\n        }\n        const pendingPromise = ReadableStreamAddReadRequest(stream);\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        return pendingPromise;\n    }\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (shouldPull === false) {\n        return;\n    }\n    if (controller._pulling === true) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain === true) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n        return false;\n    }\n    if (controller._started === false) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const stream = controller._controlledReadableStream;\n    const state = stream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (controller._closeRequested === false && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    function startAlgorithm() {\n        return InvokeOrNoop(underlyingSource, 'start', [controller]);\n    }\n    const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n    const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading === true) {\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readPromise = transformPromiseWith(ReadableStreamDefaultReaderRead(reader), result => {\n            reading = false;\n            const done = result.done;\n            if (done === true) {\n                if (canceled1 === false) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (canceled2 === false) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                return;\n            }\n            const value = result.value;\n            const value1 = value;\n            const value2 = value;\n            // There is no way to access the cloning code right now in the reference implementation.\n            // If we add one then we'll need an implementation for serializable objects.\n            // if (canceled2 === false && cloneForBranch2 === true) {\n            //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n            // }\n            if (canceled1 === false) {\n                ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n            }\n            if (canceled2 === false) {\n                ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n            }\n        });\n        setPromiseIsHandledToTrue(readPromise);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2 === true) {\n            const compositeReason = createArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1 === true) {\n            const compositeReason = createArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() { }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    });\n    return [branch1, branch2];\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n    return typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value;\n};\n\nclass ReadableStreamBYOBRequest {\n    /** @internal */\n    constructor() {\n        throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n    }\n    get view() {\n        if (IsReadableStreamBYOBRequest(this) === false) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (IsReadableStreamBYOBRequest(this) === false) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer) === true) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (IsReadableStreamBYOBRequest(this) === false) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (IsDetachedBuffer(view.buffer) === true) ;\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nclass ReadableByteStreamController {\n    /** @internal */\n    constructor() {\n        throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n    }\n    get byobRequest() {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n            this._byobRequest = byobRequest;\n        }\n        return this._byobRequest;\n    }\n    get desiredSize() {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    close() {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested === true) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        if (this._closeRequested === true) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n        }\n        if (IsDetachedBuffer(chunk.buffer) === true) ;\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    error(e) {\n        if (IsReadableByteStreamController(this) === false) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        if (this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            firstDescriptor.bytesFilled = 0;\n        }\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps]() {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            let view;\n            try {\n                view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            }\n            catch (viewE) {\n                return promiseRejectedWith(viewE);\n            }\n            return promiseResolvedWith(ReadableStreamCreateReadResult(view, false, stream._reader._forAuthorCode));\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                return promiseRejectedWith(bufferE);\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                ctor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        const promise = ReadableStreamAddReadRequest(stream);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n        return promise;\n    }\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (shouldPull === false) {\n        return;\n    }\n    if (controller._pulling === true) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain === true) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === undefined) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = undefined;\n    controller._byobRequest = undefined;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    const buffer = TransferArrayBuffer(view.buffer);\n    const pullIntoDescriptor = {\n        buffer,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        return ReadableStreamAddReadIntoRequest(stream);\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        return promiseResolvedWith(ReadableStreamCreateReadResult(emptyView, true, stream._reader._forAuthorCode));\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            return promiseResolvedWith(ReadableStreamCreateReadResult(filledView, false, stream._reader._forAuthorCode));\n        }\n        if (controller._closeRequested === true) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            return promiseRejectedWith(e);\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    const promise = ReadableStreamAddReadIntoRequest(stream);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n    return promise;\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream) === true) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n    }\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        // TODO: Figure out whether we should detach the buffer or not here.\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested === true) {\n        return false;\n    }\n    if (controller._started === false) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (ReadableStreamHasDefaultReader(stream) === true) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream) === true) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const stream = controller._controlledReadableByteStream;\n    const state = stream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    bytesWritten = Number(bytesWritten);\n    if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n        throw new RangeError('bytesWritten must be a finite');\n    }\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.byteLength !== view.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    firstDescriptor.buffer = view.buffer;\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = undefined;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    function startAlgorithm() {\n        return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n    }\n    const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n    const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n    let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n        autoAllocateChunkSize = Number(autoAllocateChunkSize);\n        if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n            throw new RangeError('autoAllocateChunkSize must be a positive integer');\n        }\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream, forAuthorCode = false) {\n    const reader = new ReadableStreamBYOBReader(stream);\n    reader._forAuthorCode = forAuthorCode;\n    return reader;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const readIntoRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    });\n    return promise;\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        if (!IsReadableStream(stream)) {\n            throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n                'byte source');\n        }\n        if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    cancel(reason) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (IsDetachedBuffer(view.buffer) === true) ;\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        return ReadableStreamBYOBReaderRead(this, view);\n    }\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    // Controllers must implement this.\n    return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nclass ReadableStream {\n    constructor(underlyingSource = {}, strategy = {}) {\n        InitializeReadableStream(this);\n        const size = strategy.size;\n        let highWaterMark = strategy.highWaterMark;\n        const type = underlyingSource.type;\n        const typeString = String(type);\n        if (typeString === 'bytes') {\n            if (size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            if (highWaterMark === undefined) {\n                highWaterMark = 0;\n            }\n            highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else if (type === undefined) {\n            const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n            if (highWaterMark === undefined) {\n                highWaterMark = 1;\n            }\n            highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n        else {\n            throw new RangeError('Invalid type is specified');\n        }\n    }\n    get locked() {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    cancel(reason) {\n        if (IsReadableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader({ mode } = {}) {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        if (mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this, true);\n        }\n        mode = String(mode);\n        if (mode === 'byob') {\n            return AcquireReadableStreamBYOBReader(this, true);\n        }\n        throw new RangeError('Invalid mode is specified');\n    }\n    pipeThrough({ writable, readable }, { preventClose, preventAbort, preventCancel, signal } = {}) {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        if (IsWritableStream(writable) === false) {\n            throw new TypeError('writable argument to pipeThrough must be a WritableStream');\n        }\n        if (IsReadableStream(readable) === false) {\n            throw new TypeError('readable argument to pipeThrough must be a ReadableStream');\n        }\n        preventClose = Boolean(preventClose);\n        preventAbort = Boolean(preventAbort);\n        preventCancel = Boolean(preventCancel);\n        if (signal !== undefined && !isAbortSignal(signal)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough\\'s signal option must be an AbortSignal');\n        }\n        if (IsReadableStreamLocked(this) === true) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(writable) === true) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);\n        setPromiseIsHandledToTrue(promise);\n        return readable;\n    }\n    pipeTo(dest, { preventClose, preventAbort, preventCancel, signal } = {}) {\n        if (IsReadableStream(this) === false) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (IsWritableStream(dest) === false) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n        }\n        preventClose = Boolean(preventClose);\n        preventAbort = Boolean(preventAbort);\n        preventCancel = Boolean(preventCancel);\n        if (signal !== undefined && !isAbortSignal(signal)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\\'s signal option must be an AbortSignal'));\n        }\n        if (IsReadableStreamLocked(this) === true) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(dest) === true) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);\n    }\n    tee() {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return createArrayFromList(branches);\n    }\n    getIterator({ preventCancel = false } = {}) {\n        if (IsReadableStream(this) === false) {\n            throw streamBrandCheckException$1('getIterator');\n        }\n        return AcquireReadableStreamAsyncIterator(this, preventCancel);\n    }\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.getIterator,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._resolve(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode));\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._reject(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._reject(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nclass ByteLengthQueuingStrategy {\n    constructor({ highWaterMark }) {\n        this.highWaterMark = highWaterMark;\n    }\n    size(chunk) {\n        return chunk.byteLength;\n    }\n}\n\nclass CountQueuingStrategy {\n    constructor({ highWaterMark }) {\n        this.highWaterMark = highWaterMark;\n    }\n    size() {\n        return 1;\n    }\n}\n\n// Class TransformStream\nclass TransformStream {\n    constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n        const writableSizeFunction = writableStrategy.size;\n        let writableHighWaterMark = writableStrategy.highWaterMark;\n        const readableSizeFunction = readableStrategy.size;\n        let readableHighWaterMark = readableStrategy.highWaterMark;\n        const writableType = transformer.writableType;\n        if (writableType !== undefined) {\n            throw new RangeError('Invalid writable type specified');\n        }\n        const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n        if (writableHighWaterMark === undefined) {\n            writableHighWaterMark = 1;\n        }\n        writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n        const readableType = transformer.readableType;\n        if (readableType !== undefined) {\n            throw new RangeError('Invalid readable type specified');\n        }\n        const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n        if (readableHighWaterMark === undefined) {\n            readableHighWaterMark = 0;\n        }\n        readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n        startPromise_resolve(startResult);\n    }\n    get readable() {\n        if (IsTransformStream(this) === false) {\n            throw streamBrandCheckException$2('readable');\n        }\n        return this._readable;\n    }\n    get writable() {\n        if (IsTransformStream(this) === false) {\n            throw streamBrandCheckException$2('writable');\n        }\n        return this._writable;\n    }\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure === true) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\nclass TransformStreamDefaultController {\n    /** @internal */\n    constructor() {\n        throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n    }\n    get desiredSize() {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk) {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    error(reason) {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    terminate() {\n        if (IsTransformStreamDefaultController(this) === false) {\n            throw defaultControllerBrandCheckException$1('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    const transformMethod = transformer.transform;\n    if (transformMethod !== undefined) {\n        if (typeof transformMethod !== 'function') {\n            throw new TypeError('transform is not a method');\n        }\n        transformAlgorithm = chunk => PromiseCall(transformMethod, transformer, [chunk, controller]);\n    }\n    const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n        ReadableStreamDefaultControllerClose(readableController);\n    }\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure === true) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        const readableController = readable._readableStreamController;\n        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n            ReadableStreamDefaultControllerClose(readableController);\n        }\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableStream, TransformStream, WritableStream };\n//# sourceMappingURL=ponyfill.es6.mjs.map\n"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","NumberIsNaN","Number","isNaN","x","rethrowAssertionErrorRejection","typeIsObject","createArrayFromList","elements","slice","IsFiniteNonNegativeNumber","v","IsNonNegativeNumber","Infinity","Call","F","V","args","TypeError","Function","prototype","apply","call","CreateAlgorithmFromUnderlyingMethod","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","PromiseCall","arg","fullArgs","concat","promiseResolvedWith","InvokeOrNoop","O","P","value","promiseRejectedWith","ValidateAndNormalizeHighWaterMark","highWaterMark","RangeError","MakeSizeAlgorithmFromSizeFunction","size","chunk","originalPromise","Promise","originalPromiseThen","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","reason","PerformPromiseThen","promise","onFulfilled","onRejected","uponPromise","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","SimpleQueue","[object Object]","this","_cursor","_size","_front","_elements","_next","_back","length","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","push","oldFront","newFront","oldCursor","newCursor","callback","i","node","front","cursor","ReadableStreamCreateReadResult","done","forAuthorCode","Object","obj","create","ReadableStreamReaderGenericInitialize","reader","stream","_forAuthorCode","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","CancelSteps","PullSteps","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_resolve","_reject","_readRequests","ReadableStreamFulfillReadRequest","shift","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStream","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","ReadableStreamDefaultReaderRead","hasOwnProperty","_disturbed","_readableStreamController","AsyncIteratorPrototype","asyncIterator","defineProperty","enumerable","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","streamAsyncIteratorBrandCheckException","_asyncIteratorReader","result","_preventCancel","DequeueValue","container","pair","_queue","_queueTotalSize","EnqueueValueWithSize","ResetQueue","setPrototypeOf","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","type","sizeAlgorithm","controller","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","state","_promise","wasAlreadyErroring","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","forEach","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","desiredSize","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","ready","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","e","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","startAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","r","peek","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","isAbortSignal","aborted","_a","NativeDOMException","DOMException","DOMException$1","ctor","isDOMExceptionConstructor","message","Error","captureStackTrace","constructor","writable","configurable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","dest","preventClose","preventAbort","preventCancel","signal","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","next","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","_closeRequested","ReadableStreamClose","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamError","SetUpReadableStreamDefaultController","pullAlgorithm","cancelAlgorithm","NumberIsInteger","isInteger","isFinite","Math","floor","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","buffer","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","ArrayBuffer","isView","firstDescriptor","_pendingPullIntos","byteOffset","bytesFilled","byteLength","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","_byobRequest","Uint8Array","request","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","_controlledReadableByteStream","ReadableByteStreamControllerError","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerClose","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableStreamHasBYOBReader","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerEnqueue","entry","ReadableByteStreamControllerHandleQueueDrain","viewE","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","readerType","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","queue","headOfQueue","bytesToCopy","destStart","destOffset","src","srcOffset","n","set","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","ReadableByteStreamControllerClearPendingPullIntos","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","SetUpReadableByteStreamController","ReadableStreamAddReadIntoRequest","readIntoRequest","IsReadableStreamBYOBReader","ReadableStreamBYOBReader","byobReaderBrandCheckException","DataView","BYTES_PER_ELEMENT","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ReadableStream","underlyingSource","InitializeReadableStream","String","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","mode","AcquireReadableStreamBYOBReader","readable","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","canceled1","canceled2","cancelPromise","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","AcquireReadableStreamAsyncIterator","getIterator","ByteLengthQueuingStrategy","CountQueuingStrategy","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","readableSizeAlgorithm","startPromise_resolve","startPromise","_writable","CreateWritableStream","_transformStreamController","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","_readable","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","readableController","TransformStreamError","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","transformMethod","transform","flushAlgorithm","_controlledTransformStream","_transformAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","startResult","IsTransformStream","streamBrandCheckException$2","IsTransformStreamDefaultController","defaultControllerBrandCheckException$1","TransformStreamDefaultControllerTerminate","ReadableStreamDefaultControllerHasBackpressure"],"mappings":"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"}