{"version":3,"file":"web-streams-adapter.min.mjs","sources":["../../node_modules/@mattiasbuelens/web-streams-adapter/dist/web-streams-adapter.mjs"],"sourcesContent":["/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction assert(test) {\n    if (!test) {\n        throw new TypeError('Assertion failed');\n    }\n}\n\nfunction noop() {\n    return;\n}\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nfunction isStreamConstructor(ctor) {\n    if (typeof ctor !== 'function') {\n        return false;\n    }\n    var startCalled = false;\n    try {\n        new ctor({\n            start: function () {\n                startCalled = true;\n            }\n        });\n    }\n    catch (e) {\n        // ignore\n    }\n    return startCalled;\n}\nfunction isReadableStream(readable) {\n    if (!typeIsObject(readable)) {\n        return false;\n    }\n    if (typeof readable.getReader !== 'function') {\n        return false;\n    }\n    return true;\n}\nfunction isReadableStreamConstructor(ctor) {\n    if (!isStreamConstructor(ctor)) {\n        return false;\n    }\n    if (!isReadableStream(new ctor())) {\n        return false;\n    }\n    return true;\n}\nfunction isWritableStream(writable) {\n    if (!typeIsObject(writable)) {\n        return false;\n    }\n    if (typeof writable.getWriter !== 'function') {\n        return false;\n    }\n    return true;\n}\nfunction isWritableStreamConstructor(ctor) {\n    if (!isStreamConstructor(ctor)) {\n        return false;\n    }\n    if (!isWritableStream(new ctor())) {\n        return false;\n    }\n    return true;\n}\nfunction isTransformStream(transform) {\n    if (!typeIsObject(transform)) {\n        return false;\n    }\n    if (!isReadableStream(transform.readable)) {\n        return false;\n    }\n    if (!isWritableStream(transform.writable)) {\n        return false;\n    }\n    return true;\n}\nfunction isTransformStreamConstructor(ctor) {\n    if (!isStreamConstructor(ctor)) {\n        return false;\n    }\n    if (!isTransformStream(new ctor())) {\n        return false;\n    }\n    return true;\n}\nfunction supportsByobReader(readable) {\n    try {\n        var reader = readable.getReader({ mode: 'byob' });\n        reader.releaseLock();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction supportsByteSource(ctor) {\n    try {\n        new ctor({ type: 'bytes' });\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction createReadableStreamWrapper(ctor) {\n    assert(isReadableStreamConstructor(ctor));\n    var byteSourceSupported = supportsByteSource(ctor);\n    return function (readable, _a) {\n        var type = (_a === void 0 ? {} : _a).type;\n        type = parseReadableType(type);\n        if (type === 'bytes' && !byteSourceSupported) {\n            type = undefined;\n        }\n        if (readable.constructor === ctor) {\n            if (type !== 'bytes' || supportsByobReader(readable)) {\n                return readable;\n            }\n        }\n        var source = createWrappingReadableSource(readable, { type: type });\n        return new ctor(source);\n    };\n}\nfunction createWrappingReadableSource(readable, _a) {\n    var type = (_a === void 0 ? {} : _a).type;\n    assert(isReadableStream(readable));\n    assert(readable.locked === false);\n    type = parseReadableType(type);\n    var source;\n    if (type === 'bytes') {\n        source = new WrappingReadableByteStreamSource(readable);\n    }\n    else {\n        source = new WrappingReadableStreamDefaultSource(readable);\n    }\n    return source;\n}\nfunction parseReadableType(type) {\n    var typeString = String(type);\n    if (typeString === 'bytes') {\n        return typeString;\n    }\n    else if (type === undefined) {\n        return type;\n    }\n    else {\n        throw new RangeError('Invalid type is specified');\n    }\n}\nvar AbstractWrappingReadableStreamSource = /** @class */ (function () {\n    function AbstractWrappingReadableStreamSource(underlyingStream) {\n        this._underlyingReader = undefined;\n        this._readerMode = undefined;\n        this._readableStreamController = undefined;\n        this._pendingRead = undefined;\n        this._underlyingStream = underlyingStream;\n        // always keep a reader attached to detect close/error\n        this._attachDefaultReader();\n    }\n    AbstractWrappingReadableStreamSource.prototype.start = function (controller) {\n        this._readableStreamController = controller;\n    };\n    AbstractWrappingReadableStreamSource.prototype.cancel = function (reason) {\n        assert(this._underlyingReader !== undefined);\n        return this._underlyingReader.cancel(reason);\n    };\n    AbstractWrappingReadableStreamSource.prototype._attachDefaultReader = function () {\n        if (this._readerMode === \"default\" /* DEFAULT */) {\n            return;\n        }\n        this._detachReader();\n        var reader = this._underlyingStream.getReader();\n        this._readerMode = \"default\" /* DEFAULT */;\n        this._attachReader(reader);\n    };\n    AbstractWrappingReadableStreamSource.prototype._attachReader = function (reader) {\n        var _this = this;\n        assert(this._underlyingReader === undefined);\n        this._underlyingReader = reader;\n        var closed = this._underlyingReader.closed;\n        if (!closed) {\n            return;\n        }\n        closed\n            .then(function () { return _this._finishPendingRead(); })\n            .then(function () {\n            if (reader === _this._underlyingReader) {\n                _this._readableStreamController.close();\n            }\n        }, function (reason) {\n            if (reader === _this._underlyingReader) {\n                _this._readableStreamController.error(reason);\n            }\n        })\n            .catch(noop);\n    };\n    AbstractWrappingReadableStreamSource.prototype._detachReader = function () {\n        if (this._underlyingReader === undefined) {\n            return;\n        }\n        this._underlyingReader.releaseLock();\n        this._underlyingReader = undefined;\n        this._readerMode = undefined;\n    };\n    AbstractWrappingReadableStreamSource.prototype._pullWithDefaultReader = function () {\n        var _this = this;\n        this._attachDefaultReader();\n        // TODO Backpressure?\n        var read = this._underlyingReader.read()\n            .then(function (result) {\n            var controller = _this._readableStreamController;\n            if (result.done) {\n                _this._tryClose();\n            }\n            else {\n                controller.enqueue(result.value);\n            }\n        });\n        this._setPendingRead(read);\n        return read;\n    };\n    AbstractWrappingReadableStreamSource.prototype._tryClose = function () {\n        try {\n            this._readableStreamController.close();\n        }\n        catch (_a) {\n            // already errored or closed\n        }\n    };\n    AbstractWrappingReadableStreamSource.prototype._setPendingRead = function (readPromise) {\n        var _this = this;\n        var pendingRead;\n        var finishRead = function () {\n            if (_this._pendingRead === pendingRead) {\n                _this._pendingRead = undefined;\n            }\n        };\n        this._pendingRead = pendingRead = readPromise.then(finishRead, finishRead);\n    };\n    AbstractWrappingReadableStreamSource.prototype._finishPendingRead = function () {\n        var _this = this;\n        if (!this._pendingRead) {\n            return undefined;\n        }\n        var afterRead = function () { return _this._finishPendingRead(); };\n        return this._pendingRead.then(afterRead, afterRead);\n    };\n    return AbstractWrappingReadableStreamSource;\n}());\nvar WrappingReadableStreamDefaultSource = /** @class */ (function (_super) {\n    __extends(WrappingReadableStreamDefaultSource, _super);\n    function WrappingReadableStreamDefaultSource() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WrappingReadableStreamDefaultSource.prototype.pull = function () {\n        return this._pullWithDefaultReader();\n    };\n    return WrappingReadableStreamDefaultSource;\n}(AbstractWrappingReadableStreamSource));\nfunction toUint8Array(view) {\n    return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n}\nfunction copyArrayBufferView(from, to) {\n    var fromArray = toUint8Array(from);\n    var toArray = toUint8Array(to);\n    toArray.set(fromArray, 0);\n}\nvar WrappingReadableByteStreamSource = /** @class */ (function (_super) {\n    __extends(WrappingReadableByteStreamSource, _super);\n    function WrappingReadableByteStreamSource(underlyingStream) {\n        var _this = this;\n        var supportsByob = supportsByobReader(underlyingStream);\n        _this = _super.call(this, underlyingStream) || this;\n        _this._supportsByob = supportsByob;\n        return _this;\n    }\n    Object.defineProperty(WrappingReadableByteStreamSource.prototype, \"type\", {\n        get: function () {\n            return 'bytes';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    WrappingReadableByteStreamSource.prototype._attachByobReader = function () {\n        if (this._readerMode === \"byob\" /* BYOB */) {\n            return;\n        }\n        assert(this._supportsByob);\n        this._detachReader();\n        var reader = this._underlyingStream.getReader({ mode: 'byob' });\n        this._readerMode = \"byob\" /* BYOB */;\n        this._attachReader(reader);\n    };\n    WrappingReadableByteStreamSource.prototype.pull = function () {\n        if (this._supportsByob) {\n            var byobRequest = this._readableStreamController.byobRequest;\n            if (byobRequest !== undefined) {\n                return this._pullWithByobRequest(byobRequest);\n            }\n        }\n        return this._pullWithDefaultReader();\n    };\n    WrappingReadableByteStreamSource.prototype._pullWithByobRequest = function (byobRequest) {\n        var _this = this;\n        this._attachByobReader();\n        // reader.read(view) detaches the input view, therefore we cannot pass byobRequest.view directly\n        // create a separate buffer to read into, then copy that to byobRequest.view\n        var buffer = new Uint8Array(byobRequest.view.byteLength);\n        // TODO Backpressure?\n        var read = this._underlyingReader.read(buffer)\n            .then(function (result) {\n            var controller = _this._readableStreamController;\n            if (result.done) {\n                _this._tryClose();\n                byobRequest.respond(0);\n            }\n            else {\n                copyArrayBufferView(result.value, byobRequest.view);\n                byobRequest.respond(result.value.byteLength);\n            }\n        });\n        this._setPendingRead(read);\n        return read;\n    };\n    return WrappingReadableByteStreamSource;\n}(AbstractWrappingReadableStreamSource));\n\nfunction createWritableStreamWrapper(ctor) {\n    assert(isWritableStreamConstructor(ctor));\n    return function (writable) {\n        if (writable.constructor === ctor) {\n            return writable;\n        }\n        var sink = createWrappingWritableSink(writable);\n        return new ctor(sink);\n    };\n}\nfunction createWrappingWritableSink(writable) {\n    assert(isWritableStream(writable));\n    assert(writable.locked === false);\n    var writer = writable.getWriter();\n    return new WrappingWritableStreamSink(writer);\n}\nvar WrappingWritableStreamSink = /** @class */ (function () {\n    function WrappingWritableStreamSink(underlyingWriter) {\n        var _this = this;\n        this._writableStreamController = undefined;\n        this._pendingWrite = undefined;\n        this._state = \"writable\" /* WRITABLE */;\n        this._storedError = undefined;\n        this._underlyingWriter = underlyingWriter;\n        this._errorPromise = new Promise(function (resolve, reject) {\n            _this._errorPromiseReject = reject;\n        });\n        this._errorPromise.catch(noop);\n    }\n    WrappingWritableStreamSink.prototype.start = function (controller) {\n        var _this = this;\n        this._writableStreamController = controller;\n        this._underlyingWriter.closed\n            .then(function () {\n            _this._state = \"closed\" /* CLOSED */;\n        })\n            .catch(function (reason) { return _this._finishErroring(reason); });\n    };\n    WrappingWritableStreamSink.prototype.write = function (chunk) {\n        var _this = this;\n        var writer = this._underlyingWriter;\n        // Detect past errors\n        if (writer.desiredSize === null) {\n            return writer.ready;\n        }\n        var writeRequest = writer.write(chunk);\n        // Detect future errors\n        writeRequest.catch(function (reason) { return _this._finishErroring(reason); });\n        writer.ready.catch(function (reason) { return _this._startErroring(reason); });\n        // Reject write when errored\n        var write = Promise.race([writeRequest, this._errorPromise]);\n        this._setPendingWrite(write);\n        return write;\n    };\n    WrappingWritableStreamSink.prototype.close = function () {\n        var _this = this;\n        if (this._pendingWrite === undefined) {\n            return this._underlyingWriter.close();\n        }\n        return this._finishPendingWrite().then(function () { return _this.close(); });\n    };\n    WrappingWritableStreamSink.prototype.abort = function (reason) {\n        if (this._state === \"errored\" /* ERRORED */) {\n            return undefined;\n        }\n        var writer = this._underlyingWriter;\n        return writer.abort(reason);\n    };\n    WrappingWritableStreamSink.prototype._setPendingWrite = function (writePromise) {\n        var _this = this;\n        var pendingWrite;\n        var finishWrite = function () {\n            if (_this._pendingWrite === pendingWrite) {\n                _this._pendingWrite = undefined;\n            }\n        };\n        this._pendingWrite = pendingWrite = writePromise.then(finishWrite, finishWrite);\n    };\n    WrappingWritableStreamSink.prototype._finishPendingWrite = function () {\n        var _this = this;\n        if (this._pendingWrite === undefined) {\n            return Promise.resolve();\n        }\n        var afterWrite = function () { return _this._finishPendingWrite(); };\n        return this._pendingWrite.then(afterWrite, afterWrite);\n    };\n    WrappingWritableStreamSink.prototype._startErroring = function (reason) {\n        var _this = this;\n        if (this._state === \"writable\" /* WRITABLE */) {\n            this._state = \"erroring\" /* ERRORING */;\n            this._storedError = reason;\n            var afterWrite = function () { return _this._finishErroring(reason); };\n            if (this._pendingWrite === undefined) {\n                afterWrite();\n            }\n            else {\n                this._finishPendingWrite().then(afterWrite, afterWrite);\n            }\n            this._writableStreamController.error(reason);\n        }\n    };\n    WrappingWritableStreamSink.prototype._finishErroring = function (reason) {\n        if (this._state === \"writable\" /* WRITABLE */) {\n            this._startErroring(reason);\n        }\n        if (this._state === \"erroring\" /* ERRORING */) {\n            this._state = \"errored\" /* ERRORED */;\n            this._errorPromiseReject(this._storedError);\n        }\n    };\n    return WrappingWritableStreamSink;\n}());\n\nfunction createTransformStreamWrapper(ctor) {\n    assert(isTransformStreamConstructor(ctor));\n    return function (transform) {\n        if (transform.constructor === ctor) {\n            return transform;\n        }\n        var transformer = createWrappingTransformer(transform);\n        return new ctor(transformer);\n    };\n}\nfunction createWrappingTransformer(transform) {\n    assert(isTransformStream(transform));\n    var readable = transform.readable, writable = transform.writable;\n    assert(readable.locked === false);\n    assert(writable.locked === false);\n    var reader = readable.getReader();\n    var writer;\n    try {\n        writer = writable.getWriter();\n    }\n    catch (e) {\n        reader.releaseLock(); // do not leak reader\n        throw e;\n    }\n    return new WrappingTransformStreamTransformer(reader, writer);\n}\nvar WrappingTransformStreamTransformer = /** @class */ (function () {\n    function WrappingTransformStreamTransformer(reader, writer) {\n        var _this = this;\n        this._transformStreamController = undefined;\n        this._onRead = function (result) {\n            if (result.done) {\n                return;\n            }\n            _this._transformStreamController.enqueue(result.value);\n            return _this._reader.read().then(_this._onRead);\n        };\n        this._onError = function (reason) {\n            _this._flushReject(reason);\n            _this._transformStreamController.error(reason);\n            _this._reader.cancel(reason).catch(noop);\n            _this._writer.abort(reason).catch(noop);\n        };\n        this._onTerminate = function () {\n            _this._flushResolve();\n            _this._transformStreamController.terminate();\n            var error = new TypeError('TransformStream terminated');\n            _this._writer.abort(error).catch(noop);\n        };\n        this._reader = reader;\n        this._writer = writer;\n        this._flushPromise = new Promise(function (resolve, reject) {\n            _this._flushResolve = resolve;\n            _this._flushReject = reject;\n        });\n    }\n    WrappingTransformStreamTransformer.prototype.start = function (controller) {\n        this._transformStreamController = controller;\n        this._reader.read()\n            .then(this._onRead)\n            .then(this._onTerminate, this._onError);\n        var readerClosed = this._reader.closed;\n        if (readerClosed) {\n            readerClosed\n                .then(this._onTerminate, this._onError);\n        }\n    };\n    WrappingTransformStreamTransformer.prototype.transform = function (chunk) {\n        return this._writer.write(chunk);\n    };\n    WrappingTransformStreamTransformer.prototype.flush = function () {\n        var _this = this;\n        return this._writer.close()\n            .then(function () { return _this._flushPromise; });\n    };\n    return WrappingTransformStreamTransformer;\n}());\n\nexport { createReadableStreamWrapper, createTransformStreamWrapper, createWrappingReadableSource, createWrappingTransformer, createWrappingWritableSink, createWritableStreamWrapper };\n//# sourceMappingURL=web-streams-adapter.mjs.map\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","assert","test","TypeError","noop","typeIsObject","x","isStreamConstructor","ctor","startCalled","start","e","isReadableStream","readable","getReader","isWritableStream","writable","getWriter","isTransformStream","transform","supportsByobReader","mode","releaseLock","_a","createReadableStreamWrapper","isReadableStreamConstructor","byteSourceSupported","type","supportsByteSource","parseReadableType","undefined","source","createWrappingReadableSource","locked","WrappingReadableByteStreamSource","WrappingReadableStreamDefaultSource","typeString","String","RangeError","AbstractWrappingReadableStreamSource","underlyingStream","_underlyingReader","_readerMode","_readableStreamController","_pendingRead","_underlyingStream","_attachDefaultReader","controller","cancel","reason","_detachReader","reader","_attachReader","_this","closed","then","_finishPendingRead","close","error","catch","_pullWithDefaultReader","read","result","done","_tryClose","enqueue","value","_setPendingRead","readPromise","pendingRead","finishRead","afterRead","_super","apply","arguments","pull","toUint8Array","view","Uint8Array","buffer","byteOffset","byteLength","supportsByob","call","_supportsByob","defineProperty","get","enumerable","configurable","_attachByobReader","byobRequest","_pullWithByobRequest","from","to","fromArray","respond","set","createWritableStreamWrapper","isWritableStreamConstructor","sink","createWrappingWritableSink","writer","WrappingWritableStreamSink","underlyingWriter","_writableStreamController","_pendingWrite","_state","_storedError","_underlyingWriter","_errorPromise","Promise","resolve","reject","_errorPromiseReject","_finishErroring","write","chunk","desiredSize","ready","writeRequest","_startErroring","race","_setPendingWrite","_finishPendingWrite","abort","writePromise","pendingWrite","finishWrite","afterWrite","createTransformStreamWrapper","isTransformStreamConstructor","transformer","createWrappingTransformer","WrappingTransformStreamTransformer","_transformStreamController","_onRead","_reader","_onError","_flushReject","_writer","_onTerminate","_flushResolve","terminate","_flushPromise","readerClosed","flush"],"mappings":"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"}